#!/bin/bash

# This script talks to the dCache API.
#
# Design: Natalie & Onno, SURFsara.
#
# Latest version is available at: https://github.com/sara-nl/SpiderScripts
#
# Changes:
# 2020-01-28 - Onno    - Created
# 2020-02-14 - Onno    - Support for server-sent events
# 2020-02-18 - Onno    - Recursion with server-sent events
# 2020-02-24 - Onno    - Don't show bearer tokens on command line
# 2020-03-04 - Onno    - Added X509 proxy authentication and netrc authentication

usage() {
  cat <<-EOF
	ADA - Access dCache API to manage your data.
	Usage: $0 [general options...] [authentication] <command> [command options]

	General options:

	  --api
	      The dCache API URL to talk to.

	  --debug
	      Show what's going on.

	Authentication options:

	  --tokenfile <filename>
	      Authenticate with the token in this file.
	      This can be an rclone config file with a
	      bearer_token statement, or a plain file with
	      only the token.

	  --netrc [filename]
	      Authenticate with a curl netrc file
	      containing username and password.
	      If no filename was provided, use ~/.netrc.

	  --proxy [filename]
	      Authenticate with a Grid proxy.
	      If no filename was provided, use \$X509_USER_PROXY.

	Commands:

	  --help
	      Show this helptext.

	  --whoami
	      Show how dCache identifies you.

	  --list <directory>
	      List a directory.

	  --longlist <file|directory>
	      List a file or directory with details.
	  --longlist --from-file <file-list>
	      List the files or directories specified in the given file.

	  --mkdir <directory>
	      Create a directory.

	  --mv <file|directory> <destination>
	      Rename or move a file or directory.

	  --delete <file|directory>
	      Delete a file or (empty) directory.
	      To recursively delete a directory and its contents,
	      we suggest you try rclone.

	  --checksum <file>
	      Show MD5/Adler32 checksums for file.
	  --checksum <directory>
	      Show MD5/Adler32 checksums for files in directory.
	  --checksum --from-file <file-list>
	      Show MD5/Adler32 checksums for files in the list.

	  --stage <file>
	      Stage a file from tape (restore, bring it online).
	  --stage <directory>
	      Stage files in directory.
	  --stage --from-file <file-list>
	      Stage files in the list.

	  --unstage <file>
	      Release file so dCache may purge its online replica.
	  --unstage <directory>
	      Release files in directory.
	  --unstage --from-file <file-list>
	      Release files in the list.

	  --events <channel-name> <path-to-follow> [--recursive] [--timeout s]
	      Subscribe to changes in the given direcory,
	      using server-sent events (SSE).
	      When --recursive is added, all subdirectories will be
	      followed as well, including any new subdirectories
	      that will be created.
	      With --timeout a timeout in seconds can be set. When
	      a channel is not being followed, dCache may clean it up
	      after this timeout. Events that have not been processed
	      will then be lost.

	  --channels [channel-name]
	      List your existing channels and their properties.
	      If the channel name is given, list channel(s) with that name.

	Examples:
	  $0 ... (todo)

	Default values can be stored in /etc/ada.conf and ~/.ada/ada.conf.
	For example:
	api='https://prometheus.desy.de:3880/api/v1/'

	EOF
  exit 1
}


# Set default values
api=
debug=false
path=
recursive=false
command=
channel_timeout=3600
auth_method=

# Load defaults from configuration file if exists
declare -a configfiles=( /etc/ada.conf ~/.ada/ada.conf )
for configfile in ${configfiles[@]} ; do
  if [ -f "$configfile" ] ; then
    $debug && echo "Loading $configfile"
    source "$configfile"
  fi
done

# If no arguments are provided, show help.
if [ -z "$1" ] ; then
  usage
fi

# Process command line arguments
while [ $# -gt 0 ] ; do
  case "$1" in
    --help | -help | -h )
      usage
      ;;
    --tokenfile )
      auth_method=token
      tokenfile="$2"
      shift ; shift
      ;;
    --netrc )
      auth_method=netrc
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          netrcfile=~/.netrc
          ;;
        * )
          # This must be a file name
          netrcfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --proxy )
      auth_method=proxy
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a file name
          proxyfile="$X509_USER_PROXY"
          ;;
        * )
          # This must be a file name
          proxyfile="$2"
          shift
          ;;
      esac
      shift
      ;;
    --api )
      api="$2"
      shift ; shift
      ;;
    --whoami )
      command=whoami
      shift
      ;;
    --list )
      command=list
      path="$2"
      shift ; shift
      ;;
    --longlist )
      command=longlist
      if [ "$2" = "--from-file" ] ; then
        $debug && echo "Reading list '$3'"
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --mkdir )
      command=mkdir
      path="$2"
      shift ; shift
      ;;
    --mv )
      command=mv
      path="$2"
      destination="$3"
      shift ; shift ; shift
      ;;
    --delete )
      command=delete
      path="$2"
      shift ; shift
      ;;
    --checksum )
      command=checksum
      if [ "$2" = "--from-file" ] ; then
       	pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --stage )
      command=stage
      if [[ $2 =~ ^--from-?file ]] ; then
        pathlist=$(<"$3")
       	shift ;	shift ;	shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --unstage )
      command=unstage
      if [[ $2 =~ ^--from-?file ]] ; then
        pathlist=$(<"$3")
        shift ; shift ; shift
      else
        pathlist="$2"
        shift ; shift
      fi
      ;;
    --events )
      command=events
      channelname="$2"
      path="$3"
      shift ; shift ; shift
      ;;
    --recursive )
      recursive=true
      shift
      ;;
    --timeout )
      channel_timeout="$2"
      shift ; shift
      ;;
    --channels )
      command=channels
      case $2 in
        --* | '' )
          # Next argument is another option or absent; not a channel name
          ;;
        * )
          # This must be a channel name
          channelname="$2"
          shift
          ;;
      esac
      shift
      ;;
    --debug )
      debug=true
      shift
      ;;
    *)
      echo "ERROR: unknown option '$1'."
      usage
      ;;
  esac
done



#
# Validate input
#

# We need some external commands.
for external_command in curl jq sed grep column sort tr ; do
  if ! command -v "$external_command" >/dev/null 2>&1 ; then
    echo >&2 "ERROR: I require '$external_command' but it's not installed."
    exit 1
  fi
done

case $auth_method in
  token )
    if [ -z "$tokenfile" ] ; then
      echo "ERROR: no tokenfile specified."
      exit 1
    fi

    token=$(sed -n 's/^bearer_token *= *//p' "$tokenfile")
    if [ $(wc -l <<<"$token") -gt 1 ] ; then
      echo "ERROR: file '$tokenfile' contains multiple tokens."
      exit 1
    fi
    # If it was not an rclone config file, it may be a 
    # plain text file with only the token.
    if [ -z "$token" ] ; then
      token=$(head -n 1 "$tokenfile")
    fi
    if [ -z "$token" ] ; then
      echo "ERROR: could not read token from tokenfile."
      exit 1
    fi
    ;;
  netrc )
    if [ ! -f "$netrcfile" ] ; then
      echo "ERROR: could not open netrc file '$netrcfile'."
      exit 1
    fi
    ;;
  proxy )
    if [ ! -f "$proxyfile" ] ; then
      echo "ERROR: could not open proxy '$proxyfile'."
      exit 1
    fi
    if [ ! -d /etc/grid-security/certificates ] ; then
      echo "ERROR: could not find /etc/grid-security/certificates/." \
           "Please install the Grid root certificates if you want to use your proxy."
      exit 1
    fi
    ;;
  * )
    echo "ERROR: you have to specify a valid authentication method."
    exit 1
    ;;
esac


case $command in
  list | mkdir | mv | delete | events )
    if [[ -z $path || $path =~ ^-- ]] ; then
      echo "ERROR: command $command requires a path."
      exit 1
    fi
    case $command in
      mv )
        if [[ -z $destination || $destination =~ ^-- ]] ; then
          echo "ERROR: command $command requires a destination."
          exit 1
        fi
        ;;
      events )
        if [[ -z $channelname || $channelname =~ ^-- ]] ; then
          echo "ERROR: command $command requires a channel name."
          exit 1
        fi
        ;;
    esac
    ;;
  longlist | checksum | stage | unstage )
    if [[ -z $pathlist || $pathlist =~ ^-- ]] ; then
      echo "ERROR: command $command requires a path or a path list."
      exit 1
    fi
    ;;
  '' )
    echo "ERROR. Please specify a command. See --help for more information."
    exit 1
    ;;
  whoami | channels )
    ;;
  * )
    echo "ERROR: command '$command' is not implemented."
    exit 1
    ;;
esac

if [ -z "$api" ] ; then
  echo "ERROR: no API specified. Use --api <api> or specify a default API in one of the configuration files (${configfiles[@]})."
  exit 1
fi

#
# End of input validation
#



#
# Construction of curl command arguments.
# These are put in arrays for easier handling of quotes.
#

# Construct the authorization part of the curl command.
case $auth_method in
  token )
    # We can't specify the token as a command line argument,
    # because others could read that with the ps command.
    # So we have to put the authorization header in a temporary file.
    mkdir -p ~/.ada/headers
    chmod 700 ~/.ada
    chmod 700 ~/.ada/headers
    curl_authorization_header_file=$(mktemp -p ~/.ada/headers authorization_header_XXXXXXXXXXXX)
    chmod 600 "$curl_authorization_header_file"
    # File should be cleaned up when we're done,
    # unless we're debugging
    if $debug ; then
      trap "{
              echo
              echo 'WARNING: in debug mode, the authorization header file' \
                   '$curl_authorization_header_file will not be cleaned up.' \
                   'Please clean it up yourself.'
            }" EXIT
    else
      trap 'rm -f "$curl_authorization_header_file"' EXIT
    fi
    # Save the header in the file
    echo "header \"Authorization: Bearer $token\"" > "$curl_authorization_header_file"
    # Refer to the file with the header
    curl_authorization=( "--config" "$curl_authorization_header_file" )
    ;;
  netrc )
    curl_authorization=( "--netrc-file" "$netrcfile" )
    ;;
  proxy )
    curl_authorization=( --capath /etc/grid-security/certificates 
                         --cert   "$proxyfile"
                         --cacert "$proxyfile" )
    ;;
esac

# Other curl arguments
curl_options_common=(
                      -H "accept: application/json"
                      --fail --silent --show-error
                    )
curl_options_no_errors=(
                      -H "accept: application/json"
                      --fail --silent
                    )
curl_options_post=(
                    -H "content-type: application/json"
                  )
curl_options_stream=(
                      -H 'accept: text/event-stream'
                      --no-buffer
                      --fail --silent --show-error
                    )

#
# Define functions we need.
#

urlencode () {
  # We use jq for encoding the URL, because we need jq anyway.
  $debug && echo "urlencoding '$1' to '$(printf "$1" | jq -sRr @uri)'" 1>&2
  printf "$1" | jq -sRr @uri
}


pathtype () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_no_errors[@]}" \
       -X GET "$api/namespace/$path?children=false&locality=false&locations=false&qos=false" \
  | jq -r .fileType
}


get_subdirs () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_common[@]}" \
       -X GET "$api/namespace/$path?children=true&locality=false&locations=false&qos=false" \
  | jq -r '.children | .[] | if .fileType == "DIR" then .fileName else empty end'
}


get_files_in_dir () {
  local path=$(urlencode "$1")
  curl "${curl_authorization[@]}" \
       "${curl_options_common[@]}" \
       -X GET "$api/namespace/$path?children=true&locality=false&locations=false&qos=false" \
  | jq -r '.children | .[] | if .fileType == "REGULAR" then .fileName else empty end'
}


get_checksums () {
  local path="$1"
  encoded_path=$(urlencode "$path")
  (
    $debug && set -x   # If --debug is specified, show (only) curl command
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$api/namespace/$encoded_path?children=false&locality=false&locations=false&qos=false"
  ) \
  | jq -r '.pnfsId' \
  | {
      read pnfsid
      if [ -z "$pnfsid" ] ; then
        continue  # skip to next $path
      fi
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             -X GET "$api/id/$pnfsid"
      ) \
      | jq -r '.checksums | .[] | [ .type , .value ] | @tsv'
    }
}


get_channel_by_name () {
  local channelname="$1"
  channel=$(
             (
               $debug && set -x
               curl "${curl_authorization[@]}" \
                    "${curl_options_common[@]}" \
                    -X GET "$api/events/channels?client-id=$channelname"
              ) \
              | jq -r '.[]'
           )
  channel_count=$(wc -l <<<"$channel")
  if [ "$channel_count" -gt 1 ] ; then
    echo "ERROR: there is more than one channel with that name:"
    echo "$channel"
    exit 1
  fi
  echo "$channel"
}

get_channels () {
  local channelname="$1"
  local query=''
  if [ -n "$channelname" ] ; then
    query="?client-id=$channelname"
  fi
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$api/events/channels${query}"
  ) \
  | jq -r '.[]'
}

channel_subscribe () {
  local channel="$1"
  local path="$2"
  local recursive="$3"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         "${curl_options_post[@]}" \
         -X POST "$channel/subscriptions/inotify" \
         -d "{\"path\":\"$path\"}"
  )
  if $recursive ; then
    get_subdirs "$path" \
    | while read subdir ; do
      $debug && echo "Subscribing to: $path/$subdir"
      channel_subscribe "$channel" "$path/$subdir" "$recursive"
    done
  fi
}


get_subscriptions_by_channel () {
  local channel="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$channel/subscriptions"
  ) \
  | jq -r '.[]'
}


list_subscription () {
  # Shows all properties of a subscription. (Could be only a path.)
  local subscription="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$subscription"
  ) \
  | jq -r 'to_entries[] | [.key, .value] | @tsv' \
  | tr '\t' '='
}


get_path_from_subscription () {
  local subscription="$1"
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_common[@]}" \
         -X GET "$subscription"
  ) \
  | jq -r .path
}


follow_channel () {
  local channel="$1"
  declare -A subscriptions
  mkdir -p ~/.ada/channels
  chmod 700 ~/.ada
  chmod 700 ~/.ada/channels
  channel_id=$(basename "$channel")
  channel_status_file=~/.ada/channels/"channel-status-$channel_id"
  # If a file exists with the last event for this channel,
  # We should resume from that event ID.
  if [ -f "$channel_status_file" ] ; then
    last_event_id=$(grep -E --max-count=1 --only-matching \
                         '[0-9]+' "$channel_status_file")
    if [ -n "$last_event_id" ] ; then
      echo "Resuming from $last_event_id"
      last_event_id_header=(-H "Last-Event-ID: $last_event_id")
    fi
  else
    last_event_id_header=()
  fi
  (
    $debug && set -x
    curl "${curl_authorization[@]}" \
         "${curl_options_stream[@]}" \
         -X GET "$channel" \
         "${last_event_id_header[@]}"
  ) \
  | while IFS=': ' read key value ; do
      case $key in
        event )
          case $value in
            inotify | SYSTEM )
              event_type="$value"
              ;;
            * )
              echo "ERROR: don't know how to handle event type '$value'."
              cat  # Read and show everything from stdin
              exit 1
              ;;
          esac
          ;;
        id )
          # Save event number so we can resume later.
          event_id="$value"
          ;;
        data )
          case $event_type in
            inotify )
              $debug && { echo ; echo "$value" | jq --compact-output ; }
              # Sometimes there's no .event.name: 
              # then 'select (.!=null)' will output an empty string.
              object_name=$(jq -r '.event.name | select (.!=null)' <<< "$value")
              mask=$(jq -r '.event.mask | @csv' <<< "$value" | tr -d '"')
              cookie=$(jq -r '.event.cookie | select (.!=null)' <<<"$value")
              subscription=$(jq -r '.subscription' <<< "$value")
              subscription_id=$(basename "$subscription")
              # We want to output not only the file name, but the full path.
              # We get the path from the API, but we cache the result
              # in an array for performance.
              if [ ! ${subscriptions[$subscription_id]+_} ] ; then
                # Not cached yet; get the path and store it in an array.
                subscriptions[$subscription_id]=$(get_path_from_subscription "$subscription")
              fi
              path="${subscriptions[$subscription_id]}"
              #
              # If recursion is requested, we need to start following new directories.
              if $recursive ; then
                if [ "$mask" = "IN_CREATE,IN_ISDIR" ] ; then
                  channel_subscribe "$channel" "$path/$object_name" "$recursive"
                fi
              fi
              #
              # A move or rename operation consists of two events,
              # an IN_MOVED_FROM and an IN_MOVED_FROM, both with
              # a cookie (ID) to relate them.
              if [ -n "$cookie" ] ; then
                cookie_string="  cookie:$cookie"
              else
                cookie_string=
              fi
              # Here comes the output.
              echo -e "$event_type  ${path}/${object_name}  ${mask}${cookie_string}"
              #
              # When done with this event's data, save the event ID.
              # This can be used to resume the channel.
              echo "$event_id" > "$channel_status_file"
              ;;
            SYSTEM )
              # For system type events we just want the raw output.
              echo -e "$event_type  $value"              
              ;;
            '' )
              # If we get a data line that was not preceded by an 
              # event line, something is wrong.
              echo "Unexpected data line: '$value' near event ID '$event_id'."
              ;;
          esac
          ;;
        '' )
          # Empty line: this ends the current event.
          event_type=
          ;;
        * )
          echo "ERROR: don't know how to handle '$key: $value'."
          exit 1
          ;;
      esac
  done
}


#
# Execute API call(s).
#

case $command in
  whoami )
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X GET "$api/user"
    ) \
    | jq .
    ;;
  list )
    type=$(pathtype "$path")
    case $type in
      DIR )
        (
          $debug && set -x   # If --debug is specified, show (only) curl command
          curl "${curl_authorization[@]}" \
               "${curl_options_common[@]}" \
               -X GET "$api/namespace/$(urlencode "$path")?children=true&locality=false&locations=false&qos=false"
        ) \
        | jq -r '.children | .[] | [ .fileName , .fileType ] | @tsv' \
        | sed -e $'s@\tREGULAR@@' \
              -e $'s@\tDIR@/@' \
              -e $'s@\tLINK@@' \
        | sort
        ;;
      REGULAR | LINK )
        # User asked listing of a regular file (not a dir).
        # No addition data is needed, the pathtype function 
        # has already checked that the file exists;
        # So we only list the file name. Nothing more.
        echo "$path"
        ;;
      '' )
        # No valid object. Do nothing.
        ;;
      * )
        echo "Unknown object type '$type'. Please create an issue for this in Github."
        ;;
    esac
    ;;
  longlist )
    while read path ; do
      type=$(pathtype "$path")
      encoded_path=$(urlencode "$path")
      case $type in
        DIR )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                 -X GET "$api/namespace/$encoded_path?children=true&locality=true&locations=false&qos=true"
          ) \
          | jq -r '.children | .[]
                   | [ .fileName ,
                       .fileType ,
                       .size ,
                       (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                       .currentQos ,
                       .fileLocality ]
                   | @tsv' \
          | sed -e $'s@\tREGULAR@@' \
                -e $'s@\tDIR@/@' \
                -e $'s@\tLINK@ยง@'
          # Note: it would be better to use strflocaltime instead of strftime,
          # but that requires a newer version of jq than Centos 7 has.
          ;;
        REGULAR | LINK )
          (
            $debug && set -x   # If --debug is specified, show (only) curl command
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                  -X GET "$api/namespace/$encoded_path?children=false&locality=true&locations=false&qos=true"
          ) \
          | jq -r '[ .size ,
                     (.mtime / 1000 | strftime("%Y-%m-%d %H:%M UTC")) ,
                     .currentQos ,
                     .fileLocality ]
                   | @tsv' \
          | sed -e "s@^@$path\t@"
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t' \
    | sort
    ;;    
  mkdir )
    parent=$(urlencode $(dirname "$path"))
    name=$(basename "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           "${curl_options_post[@]}" \
           -X POST "$api/namespace/$parent" \
           -d "{\"action\":\"mkdir\",\"name\":\"$name\"}"
    ) \
    | jq -r .status
    ;;
  mv )
    # dCache may overwrite an empty directory.
    # If target already exists, quit.
    case $(pathtype "$destination") in
      DIR | REGULAR | LINK )
        echo "ERROR: target '$destination' already exists."
        exit 1
        ;;
    esac
    encoded_path=$(urlencode "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           "${curl_options_post[@]}" \
           -X POST "$api/namespace/$encoded_path" \
           -d "{\"action\":\"mv\",\"destination\":\"$destination\"}"
    ) \
    | jq -r .status
    ;;
  delete )
    encoded_path=$(urlencode "$path")
    (
      $debug && set -x   # If --debug is specified, show (only) curl command
      curl "${curl_authorization[@]}" \
           "${curl_options_common[@]}" \
           -X DELETE "$api/namespace/$encoded_path"
    ) \
    | jq -r .status
    ;;
  checksum )
    while read path ; do
      type=$(pathtype "$path")
      case $type in
        DIR )
          # It's a directory. Show checksums for files in directory.
          get_files_in_dir "$path" \
          | while read filename ; do
            echo -n -e "$path/$filename\t"
            get_checksums "$path/$filename" | sed -e 's/\t/=/' | tr '\n' '\t'
            echo
          done
          ;;
        REGULAR )
          # It's a file. Show its checksums.
          echo -n -e "$path\t"
          get_checksums "$path" | sed -e 's/\t/=/' | tr '\n' '\t'
          echo
          ;;
        '' | LINK )
          # No valid object. Do nothing.
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t'
    ;;
  stage | unstage )
    case $command in
      stage   )  target='disk+tape'  ;;
      unstage )  target='tape'       ;;
    esac
    while read path ; do
      type=$(pathtype "$path")
      case $type in
        DIR )
          get_files_in_dir "$path" \
          | while read filename ; do
            encoded_path=$(urlencode "$path/$filename")
            $debug || echo -n "$path/$filename  "
            (
              $debug && set -x   # If --debug is specified, show (only) curl command
              curl "${curl_authorization[@]}" \
                   "${curl_options_common[@]}" \
                   "${curl_options_post[@]}" \
                   -X POST "$api/namespace/$encoded_path" \
                   -d "{\"action\":\"qos\",\"target\":\"$target\"}"
            ) | jq -r .status
          done
          ;;
        REGULAR | LINK )
          encoded_path=$(urlencode "$path")
          (
            $debug && set -x
            curl "${curl_authorization[@]}" \
                 "${curl_options_common[@]}" \
                 "${curl_options_post[@]}" \
                 -X POST "$api/namespace/$encoded_path" \
                 -d "{\"action\":\"qos\",\"target\":\"$target\"}"
          ) | jq -r .status
          ;;
        '' )
          # No valid object. Do nothing.
          ;;
        * )
          echo "Unknown object type '$type'. Please create an issue for this in Github."
          ;;
      esac
    done <<<"$pathlist" \
    | column -t -s $'\t'  
    ;;
  events )
    channel=$(get_channel_by_name "$channelname")
    if [ "$channel" = "" ] ; then
      # Channel doesn't exist; create it.
      (
        $debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X POST "$api/events/channels" -d "{\"client-id\":\"$channelname\"}"
      )
      channel=$(get_channel_by_name "$channelname")
      # There is no API call to translate channel ID back to
      # channel name. So we keep track of the name ourselves.
      channel_id=$(basename "$channel")
      echo "$channelname" > ~/.ada/channels/"channel-name-$channel_id"
      # Set channel timeout
      (
       	$debug && set -x
        curl "${curl_authorization[@]}" \
             "${curl_options_common[@]}" \
             "${curl_options_post[@]}" \
             -X PATCH "$channel" \
             -d "{\"timeout\": $channel_timeout}"
      )
    fi
    echo "Channel: $channel"
    channel_subscribe "$channel" "$path" "$recursive"
    for subscription in $(get_subscriptions_by_channel "$channel") ; do
      list_subscription "$subscription"
    done
    echo "Following..."
    follow_channel "$channel"
    ;;
  channels )
    first=true
    get_channels "$channelname" \
    | while read channel ; do
      # Show empty line between channels
      ! $first && echo
      first=false
      # Show channel ID
      echo -n $(basename "$channel")
      # Show channel name, if that was saved locally
      # (There is no API call to retrieve the channel name)
      channel_id=$(basename "$channel")
      if [ -f ~/.ada/channels/"channel-name-$channel_id" ] ; then
        channelname=$(< ~/.ada/channels/"channel-name-$channel_id")
        echo -n "  name=$channelname"
      fi
      # Show channel properties (for now only the timeout)
      channel_properties=$(
         curl "${curl_authorization[@]}" \
              "${curl_options_common[@]}" \
              -X GET "$channel" \
         | jq -r 'to_entries[] | [.key, .value] | @tsv' \
         | tr '\t' '='
      )
      # Show event ID, if available
      channel_status_file=~/.ada/channels/"channel-status-$channel_id"
      if [ -f "$channel_status_file" ] ; then
        last_event_id=$(grep -E --max-count=1 --only-matching \
                             '[0-9]+' "$channel_status_file")
        if [ -n "$last_event_id" ] ; then
          echo -n "  last-event-id=$last_event_id"
        fi
      fi
      echo "  $channel_properties"
      # Next, show all subscribed paths in this channel.
      get_subscriptions_by_channel "$channel" \
      | while read subscription ; do
        {
          echo -n $(basename "$subscription") " "
          list_subscription "$subscription"
        }
      done \
      | sort -k 2,2 \
      | sed -e 's/^/  /'
    done
    ;;
  * )
    echo "Command '$command' is not implemented (yet)."
    ;;
esac
